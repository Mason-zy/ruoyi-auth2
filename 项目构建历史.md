# 项目构建历史

## 功能添加

### 2024-07-04 添加BladeX认证集成功能

添加了与BladeX系统的简单认证集成，包括：

1. 创建了BladeAuthUtil工具类，用于与BladeX认证服务交互
2. 创建了BladeAuthController控制器，处理BladeX认证回调
3. 在application.yml中添加了BladeX认证相关配置

集成使用了轻量级设计，采用Map而非实体类接收认证响应，减少了不必要的复杂度。整个认证流程如下：

1. 用户点击"使用BladeX登录"按钮跳转到BladeX授权页
2. 用户在BladeX系统完成授权后重定向回应用
3. 应用使用授权码调用BladeX认证服务获取token
4. 前端保存token并在后续请求中使用

### 2024-07-05 实现BladeX与若依原生登录流程集成

使用与若依原生登录一致的方式处理BladeX认证用户：

1. 通过授权码获取BladeX令牌和用户信息
2. 根据返回的用户名在若依系统中查找用户
3. 找到用户后完全按照若依原生流程构建登录令牌：
   - 使用UserDetailsServiceImpl创建LoginUser对象
   - 记录登录IP和时间
   - 使用TokenService生成JWT令牌
   - 将令牌缓存到Redis
4. 前端接收若依令牌并进行登录

优势：
- 完全复用了若依原生登录流程后半部分
- 令牌格式、存储、过期机制与原生系统保持一致
- 最小化修改，降低集成风险
- BladeX用户享有与普通登录用户相同的体验

### 2024-07-05 实现BladeX令牌管理

实现了完整的BladeX令牌管理机制，支持以下功能：

1. 将用户的BladeX令牌与若依用户ID绑定存储在Redis中
2. 提供令牌管理器BladeTokenManager，负责令牌的存储、获取和删除
3. 实现BladeX API调用客户端，支持使用用户令牌调用BladeX API
4. 在用户登录成功时自动保存BladeX令牌
5. 提供测试接口，用于验证令牌状态和调用BladeX API

主要组件：
- BladeToken：存储用户的BladeX令牌信息
- BladeTokenManager：管理令牌的存储、获取和删除
- BladeApiClient：用于调用BladeX API的客户端
- BladeApiController：提供BladeX API调用相关接口

整个令牌管理流程如下：
1. 用户通过BladeX认证并获取授权码
2. 授权码传递到后端，获取BladeX访问令牌
3. 用户在若依系统中成功登录后，将BladeX令牌与用户ID绑定存储在Redis
4. 调用BladeX API时，从Redis获取对应用户的令牌并添加到请求头
5. 令牌过期时，通过接口通知用户重新登录

这种设计保证了每个用户的BladeX令牌互相隔离，并且与用户会话生命周期保持一致。当令牌过期或用户登出时，相应的BladeX令牌也会被清除。

## 问题修复

### 2024-07-04 修复BladeX认证接口访问权限问题

#### 问题描述
BladeX认证回调接口需要登录才能访问，导致单点登录流程中断，前端接收到JWT格式错误的提示。

#### 问题原因
在Spring Security的配置中，BladeX认证回调接口`/blade/auth/callback`没有被添加到匿名访问白名单中，导致未登录用户无法访问该接口。

#### 解决方案
在`SecurityConfig.java`中将`/blade/auth/callback`接口添加到匿名访问白名单中，允许未登录用户访问认证回调接口：
```java
.antMatchers("/blade/auth/callback").permitAll()
```

### 2024-07-04 调整BladeX接口命名与路径

#### 问题描述
前端回调路径和后端接口路径不匹配，接口命名不合理，导致授权失败。

#### 问题原因
后端接口命名为`/blade/auth/callback`，而实际功能是获取BladeX用户令牌信息，与前端回调路径`/auth/blade-callback`容易混淆。前者是API接口，后者是页面URL。

#### 解决方案
1. 将后端接口路径从`/blade/auth/callback`改为`/blade/auth/getTokenInfo`，更准确地反映其功能
2. 修改前端调用接口的URL路径，确保与后端匹配
3. 更新安全配置，允许新的API路径匿名访问

这样明确区分了：
- 前端回调页面路径：`/auth/blade-callback`（BladeX重定向到若依的页面URL）
- 后端API接口路径：`/blade/auth/getTokenInfo`（获取BladeX用户令牌的接口）

### 2024-07-04 添加BladeX认证配置项和调试日志

#### 问题描述
BladeX认证服务配置项未填充实际值，导致认证失败，前端显示"未配置BladeX认证服务"错误。

#### 问题原因
在application.yml文件中，虽然添加了BladeX认证的配置结构，但未填入实际的认证服务地址、客户端ID、密钥和回调URI等参数。

#### 解决方案
1. 根据前端环境变量(.env.development)中的配置，填充application.yml中的BladeX认证配置项：
```yaml
blade:
  auth:
    url: https://auth.we-safer.net/oauth/token
    client-id: chem_ruoyi
    client-secret: chem_ruoyi_secret
    redirect-uri: http://192.168.100.106:81/auth/blade-callback
```

2. 添加更多的日志输出，帮助排查认证过程中的问题：
   - 在BladeAuthUtil中添加详细的请求参数和响应日志
   - 在BladeAuthController中增加配置项检查和请求处理日志
   - 在前端BladeCallback.vue中添加控制台调试日志

这些改进有助于跟踪整个认证流程，快速定位问题所在。

### 2024-07-05 修复前端处理BladeX认证响应的问题

#### 问题描述
前端在接收BladeX认证响应时出现错误：`Cannot read properties of undefined (reading 'token')`，导致无法完成单点登录流程。

#### 问题原因
前端在访问`response.data.token`前没有检查`response.data`是否存在，同时没有考虑token可能直接存在于response对象中的情况，导致在解析响应数据时出现错误。

#### 解决方案
1. 在BladeCallback.vue中添加详细的调试日志，输出响应数据结构
2. 添加对`response.data`存在性的检查，防止访问undefined属性
3. 增加对直接存在于`response`中的token的支持
4. 在`handleLoginSuccess`方法中添加日志，跟踪token传递过程

修改后的代码更健壮，能够处理多种响应数据结构，确保在任何情况下都能正确提取token。

## 2023年10月15日 添加BladeX API基础客户端
- 实现了BladeX API调用的基础功能，包括令牌管理和用户信息获取

## 2023年10月20日 添加BladeX用户列表同步功能
- 增加了BladeX用户列表查询接口
- 开发了用户数据同步的前端界面

## 2023年11月5日 添加Basic认证
- 在BladeX API客户端中添加了Basic认证头
- 配置了客户端ID和密钥的注入

## 2023年11月7日 添加BladeX岗位列表查询功能
- 在BladeApiClient中增加了获取岗位列表的方法
- 在控制器中添加了岗位列表接口
- 开发了岗位列表查询的前端界面
- 支持根据岗位名称、编号和类型进行查询和分页

## 2023年11月8日 添加BladeX部门列表查询功能
- 在BladeApiClient中增加了获取部门列表的方法
- 在控制器中添加了部门列表接口
- 开发了部门列表查询的前端界面
- 使用树形结构展示部门的层级关系
- 通过标签标识部门的状态和类型

## 2023年11月9日 优化BladeX部门列表界面
- 将部门列表展示优化为左右分栏布局
- 左侧为部门树形结构，方便浏览整体组织架构
- 右侧为当前选中部门的详细信息
- 详情中显示部门ID、名称、全称、类型、状态、上级部门等信息
- 自动高亮当前选中的部门节点
- 添加滚动条以支持大量部门数据的浏览

## 2023年11月15日 实现BladeX部门数据同步功能
- 在SysDeptController中添加了同步BladeX部门数据的接口(/system/dept/syncBladeData)
- 实现了BladeX部门数据向若依部门结构的转换逻辑
- 开发了自动按层级排序部门的算法，确保从上到下依次同步
- 使用Map进行ID映射，处理可能的ID变化情况
- 支持新增和更新操作，记录同步的数量和结果
- 前端提供了同步功能的按钮和确认对话框
- 增加了详细的日志记录，帮助跟踪同步过程

## 2023年11月16日 重构BladeX部门同步功能实现
- 按照MVC架构规范，将同步业务逻辑从Controller层迁移到Service层
- 在ISysDeptService接口中添加了syncBladeDeptData方法
- 在SysDeptServiceImpl中实现了完整的同步逻辑
- 简化了Controller层的代码，只负责接收请求和返回结果
- 优化了日志记录，在Service层记录详细操作日志
- 改进了错误处理，使异常信息更加清晰
- 保持了原有功能的完整性，维持了按层级同步的核心算法

## 2023年11月16日 修复BladeX部门同步功能的空指针异常
### 问题描述
在同步顶级部门数据时，发生空指针异常，无法完成同步操作。日志显示：`Cannot invoke "com.ruoyi.common.core.domain.entity.SysDept.getStatus()" because "info" is null`。

### 问题原因
在`insertDept`方法中，对于所有部门都尝试查询父部门信息。对于顶级部门（parentId=0），系统中不存在其父部门，导致`info`为null，当尝试调用`info.getStatus()`方法时发生了空指针异常。

### 解决方案
1. 修改了`syncBladeDeptData`方法，增加了对顶级部门的特殊处理
2. 添加了`handleRootDeptInsert`私有方法，专门处理顶级部门的插入
3. 为顶级部门设置祖先为"0"，并设置正常状态，绕过父部门状态检查
4. 添加了更详细的错误日志，便于定位问题
5. 使用try-catch块包装每个部门的处理，确保单个部门处理失败不影响整体同步流程

## 2023年11月16日 修复BladeX部门嵌套数据同步问题
### 问题描述
同步BladeX部门数据时只有顶级部门被成功同步，所有子部门都未被处理。前端传递的是带有嵌套children结构的树形数据，而后端处理时只处理了顶层部门。

### 问题原因
同步功能接收的是一个嵌套的树状结构（带有children字段），但处理逻辑假设接收的是扁平化的部门列表，没有递归处理children中的子部门数据。

### 解决方案
1. 增加了`flattenDeptTree`方法，用于递归遍历树状结构并提取所有部门到一个扁平列表
2. 修改了`syncBladeDeptData`方法，在排序前先调用`flattenDeptTree`将树状结构扁平化
3. 添加了更详细的日志记录，显示总共需要同步的部门数量
4. 增强了处理过程中的日志记录，便于跟踪每个部门的处理状态
5. 采用了深拷贝方式创建部门对象，避免修改原始数据结构

## 2023年11月16日 修正BladeX与若依部门状态值映射
### 问题描述
BladeX系统和若依系统对部门状态值的定义不同，导致同步后部门状态不正确。状态值在两个系统中的含义刚好相反。

### 问题原因
- BladeX系统：状态值 1 表示正常，-1 表示停用
- 若依系统：状态值 0 表示正常，1 表示停用
前端传递的是BladeX格式的状态值，后端没有正确转换成若依格式，导致部门状态在同步后出现错误。

### 解决方案
1. 修改`flattenDeptTree`方法，增加状态值转换逻辑
2. 实现映射规则：BladeX状态值 1 → 若依状态值 0（正常）；BladeX状态值 -1 → 若依状态值 1（停用）
3. 增加异常状态值的处理，对于不符合预期的状态值设置默认值并记录警告日志
4. 确保顶级部门状态值正确设置为若依系统的正常状态(0)
5. 统一使用字符串类型处理状态值，避免类型转换问题

## 2023年11月16日 增强BladeX部门同步的事务管理
### 问题描述
部门同步操作涉及多个数据库操作，需要确保作为一个整体事务进行处理，在出现异常时能够回滚所有变更，避免数据不一致。

### 问题原因
之前的实现没有明确的事务边界定义，可能导致在同步过程中出现部分成功部分失败的情况，造成数据不一致。

### 解决方案
1. 使用Spring的`@Transactional`注解为同步方法添加事务支持
2. 配置事务属性：
   - 传播行为设置为REQUIRED，确保在调用链中存在统一事务
   - 隔离级别设置为READ_COMMITTED，避免脏读同时保持性能
   - 指定所有Exception类型都触发回滚，确保任何异常情况都能回滚事务
3. 优化异常处理：
   - 使用try-catch块包装整个同步过程
   - 包装并抛出更明确的异常信息，指明是同步失败并且操作已回滚
   - 增强日志记录，准确跟踪事务回滚的原因
4. 统一异常处理风格，确保Controller层能够捕获并正确展示回滚信息

## 2023年11月17日 修复BladeX部门同步重复创建问题
### 问题描述
在执行BladeX部门同步功能时，发现只能同步顶级部门，并且重复执行同步操作会导致系统创建重复的顶级部门，仅ID不同（自增）。

### 问题原因
1. 原部门同步逻辑中，判断部门是否已存在只依据ID进行判断（通过`selectDeptById`方法），没有考虑到部门名称和父级的唯一性约束。
2. ID映射表（idMapping）使用String类型作为键，导致比较过程中可能出现类型转换问题。
3. 在扁平化部门树结构时，字段映射处理不完整，有些BladeX特有字段未能正确处理。

### 解决方案
1. 添加了`findExistingDeptByNameAndParent`方法，通过部门名称和父ID查询已存在的部门，而不仅仅依赖ID。
2. 将ID映射表的键类型从String改为Long，避免字符串转换可能引发的问题。
3. 优化了扁平化处理逻辑：
   - 使代码更加简洁易读，删除了冗余注释
   - 添加了祖先字段的非空检查，防止空指针异常
   - 改进了fullName到leader字段的映射，同时支持Map和对象两种情况
4. 在更新部门时保留原有部门的ancestors信息，避免出现祖先路径错误。
5. 优化了日志输出，移除了过多的调试信息，保留关键业务日志。

这些改进使部门同步功能更加健壮，能够准确识别已存在的部门并进行更新，防止创建重复部门，同时更好地维护部门的层级结构信息。

## 2023年11月18日 重构BladeX部门同步功能解决子部门丢失问题
### 问题描述
部门同步功能中，尽管日志显示"扁平化后总共23个部门需要同步"，但实际上只有顶级部门被同步，所有子部门都丢失。即使多次运行同步，也只有顶级部门被正确处理。

### 问题原因
1. 原有的扁平化处理逻辑无法正确处理BladeX的JSON嵌套格式，特别是在处理复杂的父子关系时
2. ID映射机制依赖于Long类型，而BladeX传来的ID可能是字符串且格式不同
3. 无法正确建立BladeX原始ID和若依系统生成ID之间的映射关系
4. 子部门找不到正确的父部门ID，因为父ID映射可能失败
5. 数据类型转换问题：BladeX的数据可能是Map或SysDept的混合结构，原有代码没有灵活处理

### 解决方案
1. 完全重写了部门数据处理逻辑，改为更灵活的递归式处理：
   - 新增`processBladeDeptData`方法，专门处理BladeX的部门树结构
   - 实现`processChildDept`递归方法，正确处理任意层级的子部门
   - 添加`convertDeptToMap`和`createDeptFromBladeMap`方法，灵活处理不同数据类型
2. 改进ID映射策略：
   - 使用String类型存储BladeX原始ID，避免数值转换问题
   - 将BladeX原始ID临时存储在remark字段，父部门ID存储在leader字段
   - 建立更可靠的ID映射表，确保子部门能找到正确的父部门
3. 优化部门ID获取机制：
   - 对于新插入的部门，通过名称和父ID再次查询获取系统生成的ID
   - 更精确地将原始ID映射到系统生成的ID
4. 添加健壮的异常处理和类型转换：
   - 实现安全的字符串获取和数值转换方法
   - 添加详细的日志记录，方便跟踪问题
   - 对每个步骤进行独立的错误处理，避免单个错误影响整体流程

这些改进使部门同步功能能够正确处理任意层级的部门树结构，包括所有子部门和子子部门，同时保持了正确的层级关系和ID映射。

## 2023年11月18日 修复BladeX部门同步时子部门数据处理问题
### 问题描述
尽管前一次重构改进了部门同步逻辑，但子部门仍然无法正确同步。系统显示"从BladeX转换后总共需要同步23个部门"，但实际只有顶级部门被更新，子部门完全未处理。

### 问题原因
1. 前端传递的JSON数据格式与后端处理逻辑不匹配，导致子部门信息无法被正确解析
2. SysDept对象与Map对象之间的转换存在问题，特别是在嵌套结构中
3. 父子部门ID映射逻辑不明确，无法正确建立父子关系
4. 原始的BladeX ID和父ID追踪方式不够直接，在多层嵌套结构中容易丢失

### 解决方案
1. 重写部门数据处理方法，添加更强大的数据处理功能：
   - 直接从SysDept的params字段中尝试解析JSON数据
   - 增加了更灵活的数据转换方法，能处理多种格式的输入
   - 实现了一个简单的JSON解析器，直接处理字符串数据
2. 改进父子关系处理方式：
   - 修改子部门处理函数，使用明确的父部门ID而不是对象引用
   - 直接传递BladeX原始ID作为链接，避免中间转换导致的信息丢失
3. 优化工具函数：
   - 添加可以从多个可能的键名中获取值的工具方法
   - 增强空值和异常处理能力
   - 修复了Leader字段赋值错误（之前错误地设置给email字段）
4. 增加更详细的日志输出：
   - 添加调试级别日志，记录每个部门和子部门的处理过程
   - 明确记录ID映射关系，便于跟踪

这些改进使系统能够正确处理复杂的嵌套部门结构，维持正确的父子关系，确保所有部门（包括多级子部门）都能被正确同步。

## 2023年11月19日 简化BladeX部门同步功能，不考虑父子顺序
### 问题描述
部门同步功能实现过于复杂，特别是在处理父子关系顺序方面花费了大量逻辑。经过进一步检查发现，若依系统中部门表没有外键约束，不需要严格按照父子顺序创建部门。

### 问题原因
1. 原同步功能过度复杂化，试图严格按照父子顺序处理部门
2. 使用了复杂的ID映射和父子关系追踪机制
3. 多次转换数据格式，增加了代码复杂度和出错可能

### 解决方案
1. 完全简化同步逻辑，使用最直接的方式处理所有部门：
   - 创建`extractAllDepts`方法，一次性提取所有部门（包括子部门）到扁平列表
   - 直接循环处理所有部门，不考虑处理顺序
   - 移除复杂的ID映射机制
2. 优化部门处理：
   - 分别处理已存在和新部门的情况
   - 对顶级部门（parentId=0）特殊处理，手动设置ancestors
   - 非顶级部门直接插入，让若依系统自动处理ancestors计算
3. 提高容错性：
   - 单个部门处理出错不会影响其他部门
   - 保留全局事务，确保数据一致性
   - 简化日志输出，关注关键信息

这种简化后的实现更加高效可靠，代码更易维护，同时保证了所有部门（包括顶级部门和子部门）都能被正确同步，不需要担心处理顺序问题。

## 2024年7月26日 简化部门同步功能避免空指针异常

### 问题描述
部门同步功能在处理子部门时出现空指针异常：`Cannot invoke "com.ruoyi.common.core.domain.entity.SysDept.getStatus()" because "info" is null`，导致整个同步过程中断。

### 问题原因
在`insertDept`方法中，系统会查询父部门信息并检查其状态。对于某些子部门，可能由于父部门ID不存在（可能是BladeX系统中的ID，但在若依系统中不存在），导致查询结果为null，当尝试调用`info.getStatus()`方法时触发空指针异常。

### 解决方案
1. 简化`insertDept`方法的实现，不再强制检查父部门状态
2. 对于顶级部门（parentId为0或null），直接设置ancestors为"0"
3. 对于非顶级部门，尝试获取父部门信息：
   - 如果能获取到父部门，正常设置ancestors
   - 如果获取不到父部门，仍然允许创建，并设置默认的ancestors格式为"0,父ID"
4. 添加警告日志，记录找不到父部门的情况

这种简化的实现更适合部门同步场景，因为若依系统中部门表没有外键约束，不需要严格按照父子顺序处理部门，可以直接插入所有部门数据而不必担心顺序问题。

## 2024年7月26日 修复BladeX部门同步ID精度丢失问题

### 问题描述
在执行BladeX部门同步时，部门的ID（例如`1667350079897980929`）在数据库中被错误存储为不同的值（如`1912733410169270284`），导致无法正确识别和更新部门关系，特别是父子部门关系。

### 问题原因
大整数ID在Java到数据库的转换过程中出现精度丢失。尽管Java的Long类型和MySQL的BIGINT类型理论上都支持这么大的数字，但在处理过程（包括可能的JSON序列化、数值计算等）中可能发生精度丢失，特别是当数值超过JavaScript能精确表示的范围(2^53 - 1)时。

### 解决方案
1. 添加了专门的`convertId`方法，用于正确处理大整数ID转换：
   - 使用`BigDecimal`作为中间转换类型，确保精度不丢失
   - 针对不同类型的源数据（Long、Integer、String等）提供正确的转换逻辑
   - 添加异常处理，确保转换失败时有明确的日志记录

2. 在部门同步方法中替换原有的ID提取逻辑：
   - 使用`convertId`方法替代原来的`getStringValue`+`Long.parseLong`组合
   - 确保BladeX ID和父ID都通过精确转换处理
   - 对于null值的父ID，设置为默认值0L（表示顶级部门）

这种方法确保所有大整数ID在整个处理过程中保持精确，避免因精度问题导致的ID不匹配，从而修复了部门同步时的各种问题。

## 2024-07-20 优化BladeX部门同步实现方案

重构了BladeX部门数据同步功能，提供了更加健壮的实现方案：

1. 优化了数据接收方式，直接接收JSON格式部门数据列表，支持更灵活的数据结构
2. 简化了字段映射逻辑，遵循明确的字段对应关系：
   - id → dept_id
   - parent_id → parent_id
   - ancestors → ancestors
   - dept_name → dept_name
   - sort → order_num
   - full_name → leader
   - status → status（1→0正常, 其他→1停用）
3. 改进实现逻辑：
   - 不再依赖处理顺序，更适合批量同步
   - 同时支持更新和插入操作
   - 添加事务支持，确保数据一致性
   - 通过统计计数提供详细的同步结果报告
4. 封装了异常处理，提高代码健壮性：
   - 使用try-catch结构捕获各类异常
   - 包装异常信息，提供更友好的错误提示
   - 通过日志记录详细错误信息，便于排查
5. 优化API接口设计：
   - 使用RESTful风格接口
   - 权限控制更精确，限制访问范围
   - 接口命名更加规范和直观

## 2024-07-28 修复BladeX部门同步未处理嵌套子部门问题

### 问题描述
BladeX部门同步功能在处理部门数据时只能处理顶级部门列表，无法递归处理嵌套的子部门结构，导致大量子部门未被同步。

### 问题原因
`syncBladeDept`方法只对传入的`bladeDeptList`进行了遍历处理，没有递归查找和处理每个部门中的`children`字段中包含的子部门数据。

### 解决方案
1. 添加了`flattenDeptTree`递归方法，用于将嵌套的部门树结构扁平化处理：
   - 递归遍历每个部门的children字段
   - 将所有层级的部门添加到同一个列表中
   - 保留原有部门的所有属性和数据结构
2. 修改了`syncBladeDept`方法，在处理部门列表前先进行扁平化处理：
   - 创建一个新的列表存储扁平化后的所有部门
   - 调用`flattenDeptTree`方法填充扁平化列表
   - 使用扁平化后的列表进行后续的同步处理
3. 保持了原有的同步逻辑不变，只是改变了处理对象，确保所有部门都能被正确处理

这种实现保证了无论部门层级有多深，都能正确同步所有部门数据，解决了之前只能同步顶级部门的问题。