明白了，您需要的是BladeX用户登录到若依系统的单点登录方案。我将重新为您编写实现步骤文档。

# 若依与BladeX单点登录集成方案.md

## 一、概述

本文档详细描述了使用BladeX用户认证系统登录到若依框架的单点登录集成实现步骤。通过OAuth2授权码模式，用户可以使用BladeX的账号直接登录若依系统，实现统一的用户认证体系。

## 二、环境信息

- **BladeX系统地址**：192.168.100.48:8100（授权服务器）
- **若依系统地址**：https://gc2479vj612.vicp.fun
- **OAuth2配置信息**：
  - 应用ID：ruoyi
  - 应用密钥：ruoyi
  - 授权类型：refresh_token, password, authorization_code, captcha, social, sms_code, register
  - 授权范围：all
  - 令牌秒数：3600（1小时）
  - 刷新秒数：604800（7天）
  - 回调地址：https://gc2479vj612.vicp.fun/auth/callback
  - 自动授权：是

## 三、实现步骤

### 1. BladeX系统配置

#### 1.1 确认OAuth2客户端配置

确保BladeX系统的`blade_client`表中已配置若依系统的客户端信息：
```sql
INSERT INTO `blade_client` (
  `client_id`, 
  `client_secret`, 
  `scope`,
  `authorized_grant_types`,
  `web_server_redirect_uri`,
  `access_token_validity`,
  `refresh_token_validity`,
  `autoapprove`
) VALUES (
  'ruoyi',
  'ruoyi',
  'all',
  'refresh_token,password,authorization_code,captcha,social,sms_code,register',
  'https://gc2479vj612.vicp.fun/auth/callback',
  3600,
  604800,
  'true'
);
```

### 2. 若依系统开发

#### 2.1 添加OAuth2相关依赖

在若依系统的`pom.xml`中添加OAuth2客户端依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
```

#### 2.2 添加OAuth2配置类

创建`com.ruoyi.framework.config.OAuth2ClientConfig.java`文件：

```java
package com.ruoyi.framework.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class OAuth2ClientConfig {
    
    @Value("${blade.auth.url}")
    private String bladeAuthUrl;
    
    @Value("${blade.client.id}")
    private String clientId;
    
    @Value("${blade.client.secret}")
    private String clientSecret;
    
    @Value("${blade.redirect-uri}")
    private String redirectUri;
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### 2.3 创建BladeX单点登录服务

创建`com.ruoyi.framework.web.service.BladeSSOService.java`文件：

```java
package com.ruoyi.framework.web.service;

import java.util.Base64;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import com.ruoyi.common.core.domain.entity.SysUser;
import com.ruoyi.common.core.domain.model.LoginUser;
import com.ruoyi.system.service.ISysUserService;

@Service
public class BladeSSOService {
    
    @Value("${blade.auth.url}")
    private String bladeAuthUrl;
    
    @Value("${blade.client.id}")
    private String clientId;
    
    @Value("${blade.client.secret}")
    private String clientSecret;
    
    @Value("${blade.redirect-uri}")
    private String redirectUri;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private TokenService tokenService;
    
    @Autowired
    private ISysUserService userService;
    
    @Autowired
    private SysPermissionService permissionService;
    
    /**
     * 使用授权码获取BladeX用户信息
     */
    public Map<String, Object> getBladeUserInfo(String code, String tenantId) {
        // 构建获取令牌的请求
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        headers.set("Tenant-Id", tenantId != null ? tenantId : "000000");
        headers.set("Authorization", "Basic " + 
                Base64.getEncoder().encodeToString((clientId + ":" + clientSecret).getBytes()));
        
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("scope", "all");
        params.add("code", code);
        params.add("redirect_uri", redirectUri);
        
        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);
        
        // 发送请求获取令牌
        ResponseEntity<Map> tokenResponse = restTemplate.postForEntity(
                bladeAuthUrl + "/oauth/token", 
                request, 
                Map.class);
        
        String accessToken = (String) tokenResponse.getBody().get("access_token");
        
        // 使用令牌获取用户信息
        HttpHeaders userInfoHeaders = new HttpHeaders();
        userInfoHeaders.set("Authorization", "Bearer " + accessToken);
        userInfoHeaders.set("Tenant-Id", tenantId != null ? tenantId : "000000");
        
        HttpEntity<Void> userInfoRequest = new HttpEntity<>(userInfoHeaders);
        
        ResponseEntity<Map> userInfoResponse = restTemplate.exchange(
                bladeAuthUrl + "/blade-auth/oauth/user-info",
                HttpMethod.GET,
                userInfoRequest,
                Map.class);
        
        return userInfoResponse.getBody();
    }
    
    /**
     * 使用BladeX用户信息登录若依系统
     */
    public String loginWithBladeUser(Map<String, Object> bladeUserInfo) {
        // 在若依系统中查找或创建对应的用户
        SysUser user = findOrCreateUser(bladeUserInfo);
        
        // 生成登录用户对象
        LoginUser loginUser = new LoginUser(
                user.getUserId(),
                user.getDeptId(),
                user,
                permissionService.getMenuPermission(user)
        );
        
        // 生成token
        return tokenService.createToken(loginUser);
    }
    
    /**
     * 根据BladeX用户信息查找或创建若依用户
     */
    private SysUser findOrCreateUser(Map<String, Object> bladeUserInfo) {
        // 从BladeX用户信息中提取关键数据
        String username = (String) bladeUserInfo.get("account");
        String nickname = (String) bladeUserInfo.get("name");
        String email = (String) bladeUserInfo.get("email");
        String phone = (String) bladeUserInfo.get("phone");
        
        // 查找用户
        SysUser user = userService.selectUserByUserName(username);
        
        if (user == null) {
            // 用户不存在，创建新用户
            user = new SysUser();
            user.setUserName(username);
            user.setNickName(nickname);
            user.setEmail(email);
            user.setPhonenumber(phone);
            user.setPassword(""); // 空密码，因为使用单点登录
            user.setStatus("0"); // 正常状态
            user.setDelFlag("0"); // 未删除
            
            // 可根据需要设置其他用户属性
            
            // 创建用户
            userService.insertUser(user);
        } else {
            // 用户存在，可以选择更新用户信息
            user.setNickName(nickname);
            user.setEmail(email);
            user.setPhonenumber(phone);
            
            // 更新用户
            userService.updateUser(user);
        }
        
        return user;
    }
}
```

#### 2.4 创建OAuth回调控制器

创建`com.ruoyi.web.controller.system.OAuthCallbackController.java`文件：

```java
package com.ruoyi.web.controller.system;

import java.io.IOException;
import java.net.URLEncoder;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.ruoyi.common.core.domain.AjaxResult;
import com.ruoyi.common.exception.ServiceException;
import com.ruoyi.framework.web.service.BladeSSOService;

@RestController
@RequestMapping("/auth/callback")
public class OAuthCallbackController {
    
    @Autowired
    private BladeSSOService ssoService;
    
    @GetMapping("")
    public void handleBladeCallback(
            HttpServletRequest request, 
            HttpServletResponse response,
            @RequestParam("code") String code,
            @RequestParam(value = "state", required = false) String tenantId) throws IOException {
        
        try {
            // 使用授权码获取BladeX用户信息
            Map<String, Object> userInfo = ssoService.getBladeUserInfo(code, tenantId);
            
            // 使用BladeX用户信息在若依系统中进行登录
            String token = ssoService.loginWithBladeUser(userInfo);
            
            // 重定向到若依系统首页，带上登录令牌
            response.sendRedirect("/index?token=" + token);
        } catch (Exception e) {
            // 处理错误情况
            response.sendRedirect("/login?error=" + URLEncoder.encode(e.getMessage(), "UTF-8"));
        }
    }
}
```

#### 2.5 修改若依系统配置文件

在`application.yml`或`application-dev.yml`中添加BladeX相关配置：

```yaml
# BladeX单点登录配置
blade:
  auth:
    url: http://192.168.100.48:8100
  client:
    id: ruoyi
    secret: ruoyi
  redirect-uri: https://gc2479vj612.vicp.fun/auth/callback
```

#### 2.6 修改若依登录页面

在`ruoyi-ui/src/views/login.vue`文件中添加单点登录按钮和相关方法：

```vue
<template>
  <!-- ... 现有代码 ... -->
  <div class="other-login">
    <el-divider>
      <span class="login-tip">其他登录方式</span>
    </el-divider>
    <div class="other-login-item">
      <el-button type="primary" @click="handleSSOLogin" class="sso-button">BladeX单点登录</el-button>
    </div>
  </div>
  <!-- ... 现有代码 ... -->
</template>

<script>
export default {
  // ... 现有代码 ...
  methods: {
    // ... 现有代码 ...
    
    handleSSOLogin() {
      // 构建授权请求URL
      const authUrl = `${process.env.VUE_APP_BLADE_AUTH_URL}/oauth/authorize?` +
        `response_type=code&` +
        `redirect_uri=${encodeURIComponent(process.env.VUE_APP_SSO_CALLBACK_URL)}&` +
        `state=000000&` +  // 可以根据需要设置租户ID
        `client_id=${process.env.VUE_APP_BLADE_CLIENT_ID}`;
      
      // 跳转到授权页面
      window.location.href = authUrl;
    }
  }
}
</script>

<style>
/* ... 现有样式 ... */
.other-login {
  margin-top: 20px;
  text-align: center;
}
.login-tip {
  font-size: 13px;
  color: #909399;
}
.other-login-item {
  margin-top: 15px;
}
.sso-button {
  width: 100%;
}
</style>
```

#### 2.7 修改前端环境配置

在`.env.development`和`.env.production`文件中添加BladeX相关配置：

```
# BladeX单点登录配置
VUE_APP_BLADE_AUTH_URL=http://192.168.100.48:8100
VUE_APP_BLADE_CLIENT_ID=ruoyi
VUE_APP_SSO_CALLBACK_URL=https://gc2479vj612.vicp.fun/auth/callback
```

### 3. 修改安全配置

在`SecurityConfig.java`中添加授权回调URL到允许匿名访问的列表：

```java
@Override
protected SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
    // ... 现有代码 ...
    
    .authorizeHttpRequests((requests) -> {
        // ... 现有代码 ...
        // 添加授权回调URL到匿名访问列表
        requests.antMatchers("/auth/callback").permitAll()
        // ... 现有代码 ...
    })
    
    // ... 现有代码 ...
}
```

## 四、单点登录流程

1. **用户点击"BladeX单点登录"按钮**
   - 前端构建授权请求URL并重定向
   - 用户被带到BladeX登录页面

2. **在BladeX系统完成身份验证**
   - 用户输入BladeX的用户名和密码
   - BladeX系统验证用户身份并授权

3. **授权成功后重定向回若依系统**
   - BladeX系统生成授权码并重定向到若依回调地址
   - 若依系统接收授权码

4. **若依系统处理授权回调**
   - 使用授权码向BladeX请求访问令牌
   - 使用访问令牌获取BladeX用户信息
   - 在若依系统中查找或创建对应用户
   - 生成若依系统的登录令牌

5. **完成登录**
   - 重定向到若依系统首页，携带登录令牌
   - 用户成功登录若依系统

## 五、注意事项

1. **用户账号映射**
   - 默认使用BladeX的账号(account)作为若依的用户名
   - 需要确保账号命名规则一致，或实现更复杂的映射规则

2. **权限控制**
   - 单点登录用户在若依系统中的权限需要单独配置
   - 可考虑从BladeX同步角色和权限信息

3. **安全性**
   - 确保使用HTTPS保护数据传输
   - 验证回调请求的来源和参数有效性

4. **用户体验**
   - 在授权失败时提供清晰的错误信息
   - 考虑添加"记住我"功能，减少频繁登录

5. **系统同步**
   - 考虑定期同步两个系统的用户数据
   - 处理用户信息变更和权限变更的同步问题

此文档提供了BladeX用户登录若依系统的单点登录集成详细步骤，实现了统一用户认证，简化了用户操作流程。
